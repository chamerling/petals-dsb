/**
 * PETALS - PETALS Services Platform. Copyright (c) 2007 EBM Websourcing,
 * http://www.ebmwebsourcing.com/
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version. This library is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * 
 * -------------------------------------------------------------------------
 * $Id$
 * -------------------------------------------------------------------------
 */

package org.ow2.petals.binding.soap.listener.outgoing;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

import javax.jbi.messaging.MessagingException;

import org.apache.axiom.soap.SOAP11Constants;
import org.apache.axiom.soap.SOAP12Constants;
import org.apache.axis2.AxisFault;
import org.apache.axis2.client.Options;
import org.apache.axis2.transport.http.HttpTransportProperties;
import org.apache.commons.httpclient.auth.AuthPolicy;
import org.ow2.petals.binding.soap.SoapComponentContext;
import org.ow2.petals.binding.soap.addressing.Addressing;
import org.ow2.petals.binding.soap.addressing.WSAHelper;
import org.ow2.petals.binding.soap.util.SUPropertiesHelper;
import org.ow2.petals.component.framework.api.Constants;
import org.ow2.petals.component.framework.api.configuration.ConfigurationExtensions;
import org.ow2.petals.component.framework.api.message.Exchange;
import org.w3c.dom.Document;

import static org.ow2.petals.binding.soap.Constants.ServiceUnit.ADD_ROOT;
import static org.ow2.petals.binding.soap.Constants.ServiceUnit.BASIC_AUTH_PASSWORD;
import static org.ow2.petals.binding.soap.Constants.ServiceUnit.BASIC_AUTH_USERNAME;
import static org.ow2.petals.binding.soap.Constants.ServiceUnit.CHUNKED_MODE;
import static org.ow2.petals.binding.soap.Constants.ServiceUnit.CLEANUP_TRANSPORT;
import static org.ow2.petals.binding.soap.Constants.ServiceUnit.PROXY_DOMAIN;
import static org.ow2.petals.binding.soap.Constants.ServiceUnit.PROXY_HOST;
import static org.ow2.petals.binding.soap.Constants.ServiceUnit.PROXY_PASSWORD;
import static org.ow2.petals.binding.soap.Constants.ServiceUnit.PROXY_PORT;
import static org.ow2.petals.binding.soap.Constants.ServiceUnit.PROXY_USER;
import static org.ow2.petals.binding.soap.Constants.ServiceUnit.SOAP_ACTION;
import static org.ow2.petals.binding.soap.Constants.ServiceUnit.SOAP_VERSION;

import com.ebmwebsourcing.wsstar.addressing.definition.WSAddressingFactory;
import com.ebmwebsourcing.wsstar.addressing.definition.api.WSAddressingException;

/**
 * Abstract class for dispatchers. Dispatchers are used to send JBI message to
 * external Web Services.
 * 
 * @author chamerling - eBM WebSourcing
 * 
 */
public abstract class AbstractExternalServiceCaller implements ExternalServiceCaller {

    public static final String SOAP_VERSION_11 = "1.1";

    public static final String SOAP_VERSION_12 = "1.2";

    /**
     * The soap component context
     */
    protected SoapComponentContext soapContext;

    /**
     * The logger
     */
    protected Logger logger;

    /**
     * Creates a new instance of {@link AbstractExternalServiceCaller}
     * 
     * @param soapContext
     * @param logger
     */
    public AbstractExternalServiceCaller(final SoapComponentContext soapContext, final Logger logger) {
        this.soapContext = soapContext;
        this.logger = logger;
    }

    /**
     * Set the Exception in the JBI Message as Error.
     * 
     * @param exchange
     * @param exception
     *            The exception
     */
    protected void handleException(final Exchange exchange, final Exception exception) {
        String message = null;

        message = exception.getMessage();
        if (message == null && exception.getCause() != null) {
            message = exception.getCause().getMessage();
        }
        if (message == null) {
            message = "The exception generated by the component is unknown";
        }
        exchange.setError(new MessagingException("BC-SOAP Error => " + message));
    }

    /**
     * Set the Exception in the JBI Message as Error. Search the great
     * informations to summarize the situation into the causes of the AxisFault
     * 
     * @param exchange
     * @param axisFault
     *            The axisFault
     */
    protected void handleException(final Exchange exchange, final AxisFault axisFault) {
        String message = null;
        // the method toString() allow to know the classname of the
        // exception into the string message, and not only the content of the
        // message
        message = axisFault.toString();
        if (axisFault.getCause() != null) {
            if (message != null) {
                message += ". ";
            } else {
                message = "";
            }
            message += "The cause was " + axisFault.getCause().toString();
        }
        exchange.setError(new MessagingException("BC-SOAP Error => " + message));
    }

    /**
     * 
     * @param exchange
     * @param e
     */
    protected void handleException(final Exchange exchange, final String errorMessage) {
        exchange.setError(new MessagingException("BC-SOAP Exception => " + errorMessage));
    }

    /**
     * 
     * @param extensions
     * @return
     */
    protected final static boolean retrieveAddRoot(final ConfigurationExtensions extensions) {
        if (extensions == null) {
            return false;
        }
        final String result = extensions.get(ADD_ROOT);
        return Boolean.parseBoolean(result);
    }

    /**
     * Retrieve the default SOAP action from the extensions.
     * 
     * @param extensions
     * @return
     */
    protected final static String retrieveDefaultSOAPAction(final ConfigurationExtensions extensions) {
        if (extensions == null) {
            return null;
        }
        return extensions.get(SOAP_ACTION);
    }

    /**
     * Retrieve the proxy settings from the extensions. The proxy-host value is
     * required. The other ones will be set to default values by Axis if they
     * have not been setted by the SU.
     * 
     * 
     * @param extensions
     *            must be not null. Contains <em>proxy-*</em> optional tags.
     * 
     * @return the proxy settings if they are present in the extensions, null
     *         otherwise.
     * @see org.apache.axis2.transport.http.HttpTransportProperties.ProxyProperties
     * 
     */
    protected final static HttpTransportProperties.ProxyProperties retrieveProxySettings(
            final ConfigurationExtensions extensions) {
        if (extensions == null) {
            return null;
        }

        HttpTransportProperties.ProxyProperties proxyProperties = null;

        if (extensions.get(PROXY_HOST) != null) {
            // proxy host is required, if it is not set the proxy mode is not
            // activated

            proxyProperties = new HttpTransportProperties.ProxyProperties();

            final String domain = extensions.get(PROXY_DOMAIN);
            final String password = extensions.get(PROXY_PASSWORD);
            final String proxyHost = extensions.get(PROXY_HOST);

            int proxyPort = -1;
            final String tmp = extensions.get(PROXY_PORT);
            if (tmp != null) {
                try {
                    proxyPort = Integer.parseInt(tmp);
                } catch (final NumberFormatException e) {
                }
            }

            final String proxyUserName = extensions.get(PROXY_USER);

            proxyProperties.setDomain(domain);
            proxyProperties.setPassWord(password);
            proxyProperties.setProxyName(proxyHost);
            proxyProperties.setProxyPort(proxyPort);
            proxyProperties.setUserName(proxyUserName);
        }

        return proxyProperties;
    }

    /**
     * Retrieve, in the jbi.xml descriptor, the SOAP version to use for
     * SoapEnvelopeNamespaceURI Search a <em>soap-version</em> tag. <br>
     * Legal values are <b>1.1</b> and <b>1.2</b>. 1.1 is used if no tag is
     * found.
     * 
     * @param extensions
     *            must be non null. Contains a <em>soap-version</em> optional
     *            tag.
     * @return the Axis2 soapEnvelopeNamespaceURI constant.
     * @see org.apache.axiom.soap.SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI
     * @see org.apache.axiom.soap.SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI
     */
    protected final static String retrieveSOAPEnvelopeNamespaceURI(
            final ConfigurationExtensions extensions) {
        String soapEnvelopeNamespaceURI = SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI;
        if (extensions == null) {
            return soapEnvelopeNamespaceURI;
        }
        final String soapVersion = extensions.get(SOAP_VERSION);

        if (SOAP_VERSION_12.equals(soapVersion)) {
            soapEnvelopeNamespaceURI = SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI;
        }
        return soapEnvelopeNamespaceURI;
    }

    /**
     * Get the cleanup-transport property value (true/false).
     * 
     * @see bug #308219
     * @param extensions
     * @return
     */
    protected final static boolean retrieveCleanupTransport(final ConfigurationExtensions extensions) {
        if (extensions == null) {
            return true;
        }
        final String clean = extensions.get(CLEANUP_TRANSPORT);
        if( clean == null )
            return true;
        else
            return Boolean.valueOf(clean);
    }

    /**
     * Retrieve the chunked mode
     * 
     * @param extensions
     * @return
     */
    protected final static String retrieveChunkedMode(final ConfigurationExtensions extensions) {
        if (extensions == null) {
            return "false";
        }
        return extensions.get(CHUNKED_MODE);
    }

    /**
     * Getting the basic authentication parameters for the outgoing SOAP
     * request.
     * 
     * @param extensions
     * @param options
     * @return
     */
    @SuppressWarnings("unchecked")
    protected final static HttpTransportProperties.Authenticator retrieveBasicAuthentication(
            final ConfigurationExtensions extensions, final Options options) {
        HttpTransportProperties.Authenticator basicAuthentication = null;
        final String username = extensions.get(BASIC_AUTH_USERNAME);
        String password = extensions.get(BASIC_AUTH_PASSWORD);

        if (username != null) {
            if (password == null) {
                password = "";
            }

            basicAuthentication = new HttpTransportProperties.Authenticator();
            final List schemes = new ArrayList();
            schemes.add(AuthPolicy.BASIC);
            basicAuthentication.setAuthSchemes(schemes);
            basicAuthentication.setUsername(username);
            basicAuthentication.setPassword(password);
            basicAuthentication.setPreemptiveAuthentication(true);
            options.setProperty(org.apache.axis2.transport.http.HTTPConstants.AUTHENTICATE,
                    basicAuthentication);
        }

        return basicAuthentication;
    }

    /**
     * Get the final service address for this endpoint and message exchange.
     * This service address is defined like this :
     * <ol>
     * <li><b>If it exists</b>, get the address from the exchange
     * {@link org.ow2.petals.component.framework.api.Constants.WSStar.ADDRESSING_KEY}
     * property (OASIS/W3C standard)</li>
     * <li><b>Else, if it exists</b>, get the address from the exchange WSA-TO
     * property if found (Microsoft/IBM standard)</li>
     * <li><b>Else</b>, get the address from the Service unit</li>
     * </ol>
     * 
     * @param exchange
     *            The exchange
     * @param extensions
     *            The extensions
     * @return the address
     */
    protected final static String retrieveServiceAddress(final Exchange exchange,
            final ConfigurationExtensions extensions) {
        try {
            if (exchange.getInMessageProperty(Constants.WSStar.ADDRESSING_KEY) != null) {
                // get the property
                Object object = exchange.getInMessageProperty(Constants.WSStar.ADDRESSING_KEY);
                if (object instanceof Document) {
                    String address = WSAddressingFactory.newInstance().newWSAddressingReader()
                            .readEndpointReferenceType((Document) object).getAddress();
                    if (address != null) {
                        return address;
                    }
                }
            }
        } catch (MessagingException e) {
            // no error to throw on this property research
        } catch (WSAddressingException e) {
            // no error to throw on this property research
        }
        if (exchange.getInAddressing() != null) {
            // get the property
            return exchange.getInAddressing().get(Constants.WSStar.Addressing.TO_QNAME);
        }
        return SUPropertiesHelper.getWSATo(extensions);
    }

    /**
     * Get the addressing information from the exchange and from the service
     * unit extensions.
     * 
     * @param exchange
     * @param extensions
     * @return
     */
    protected final static Addressing retrieveAddressing(final Exchange exchange,
            final ConfigurationExtensions extensions) {
        Addressing wsAddressing = null;
        try {
            if (exchange.getInMessageProperty(Constants.WSStar.ADDRESSING_KEY) != null) {
                // get the property
                Object object = exchange.getInMessageProperty(Constants.WSStar.ADDRESSING_KEY);
                if (object instanceof Document) {
                    String address = WSAddressingFactory.newInstance().newWSAddressingReader()
                            .readEndpointReferenceType((Document) object).getAddress();
                    if (address != null) {
                        wsAddressing = WSAHelper.getAddressing(address);
                    }
                }
            }
        } catch (MessagingException e) {
            // no error to throw on this property research
        } catch (WSAddressingException e) {
            // no error to throw on this property research
        }
        Addressing wsaToAddressing = WSAHelper.getAddressing(exchange.getInAddressing());
        Addressing suAddressing = WSAHelper.getAddressing(extensions);
        return WSAHelper.merge(wsAddressing, wsaToAddressing, suAddressing);
    }
}
